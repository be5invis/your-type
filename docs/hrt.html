<!DOCTYPE html>

<html>
<head>
  <title>`hrt.js`, A Rank-N Type Inferencer</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <link rel="stylesheet" media="all" href="docco.css" />
  <script type="text/x-mathjax-config">
       MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
    </script>
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="-hrt-js-a-rank-n-type-inferencer"><code>hrt.js</code>, A Rank-N Type Inferencer</h1>
<p>本文主要参照 Simon Peyton Jones 等的论文 <em>Practical type inference for arbitrary-rank types</em> 实现了一个 Rank-N 的类型推理算法。</p>
<p>此算法的逻辑学表述可参见文献 31 页，Haskell 代码可参见其附件。这份 JavaScript 代码由其 Haskell 版本改写而来。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>


<span class="hljs-keyword">const</span> colors = <span class="hljs-built_in">require</span>(<span class="hljs-string">"colors"</span>);
<span class="hljs-keyword">const</span> stripAnsi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"strip-ansi"</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">"util"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="-gamma-">第一部分，环境 $\Gamma$</h2>
<p>我们使用「环境」来处理嵌套的作用域。每个环境包含两个部分：</p>
<ul>
<li>uniqs：一个全局的计数器引用，产生临时变量时使用</li>
<li>variables：一个字符串到类型的映射，用来记录所有已经定型的变量名</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Environment</span> </span>{
	<span class="hljs-comment">/**
	 * @param {{val:number}} uniqs
	 * @param {Map&lt;string, Type&gt;} variables
	 */</span>
	<span class="hljs-keyword">constructor</span>(uniqs, variables) {
		<span class="hljs-keyword">this</span>.uniqs = uniqs;
		<span class="hljs-keyword">this</span>.variables = variables;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h4 id="extend-this-environment-string-type-environment">extend :: <em>this</em> Environment × string × Type → Environment</h4>
<p>创建一个扩展环境 $\Gamma, x:t$，增加一个变量</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {string} name
	 * @param {Type} type
	 */</span>
	extend(name, type) {
		<span class="hljs-keyword">let</span> v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-keyword">this</span>.variables);
		v1.set(name, type);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Environment(<span class="hljs-keyword">this</span>.uniqs, v1);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h4 id="extendn-this-environment-name-string-type-type-environment">extendN :: <em>this</em> Environment × [{name: string, type: Type}] → Environment</h4>
<p>创建一个扩展环境 $\Gamma,\overline{x:t}$，增加一组变量。此函数用于 let rec 的构建</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {{name: string, type: Type}[]} terms
	 */</span>
	extendN(terms) {
		<span class="hljs-keyword">let</span> v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-keyword">this</span>.variables);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> {name, type} <span class="hljs-keyword">of</span> terms) {
			v1.set(name, type);
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Environment(<span class="hljs-keyword">this</span>.uniqs, v1);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h4 id="lookup-this-environment-string-type">lookup :: <em>this</em> Environment × string → Type</h4>
<p>查找名称定义</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {string} name
	 * @returns {Type}
	 */</span>
	lookup(name) {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.variables.has(name)) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.variables.get(name);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Variable <span class="hljs-subst">${name}</span> not found.`</span>);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h4 id="newunique-this-environment-number">newUnique :: <em>this</em> Environment → number</h4>
<p>增加计数器，生成唯一性的数值</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	newUnique() {
		<span class="hljs-keyword">this</span>.uniqs.val += <span class="hljs-number">1</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.uniqs.val;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h4 id="newvar-this-environment-string">newVar :: <em>this</em> Environment → string</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>	newVar(tag) {
		<span class="hljs-keyword">this</span>.uniqs.val += <span class="hljs-number">1</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-string">"#"</span> + (tag || <span class="hljs-string">"_"</span>) + <span class="hljs-keyword">this</span>.uniqs.val;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h4 id="newmetaslotval-this-environment-metaslotval">newMetaSlotVal :: <em>this</em> Environment → MetaSlotVal</h4>
<p>生成新的 Meta slot value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	newMetaSlotVal() {
		<span class="hljs-keyword">const</span> u = <span class="hljs-keyword">this</span>.newUnique();
		<span class="hljs-keyword">const</span> ref = { <span class="hljs-attr">val</span>: <span class="hljs-literal">null</span> };
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MetaSlotVal(u, ref);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h4 id="newskolemvariable-this-environment-string">newSkolemVariable :: <em>this</em> Environment → string</h4>
<p>生成新的 Skolem slot 名称</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	newSkolemVariable(s) {
		<span class="hljs-keyword">const</span> u = <span class="hljs-keyword">this</span>.newUnique();
		<span class="hljs-keyword">return</span> rawNameToskolmeizedName(u, s);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h4 id="gettypes-this-environment-iterableiterator-type">getTypes :: <em>this</em> Environment → IterableIterator Type</h4>
<p>获得所有已定义变量的类型列表</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	getTypes() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.variables.values();
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h4 id="gettypes-this-environment-iterableiterator-number-metaslot-">getTypes :: <em>this</em> Environment → IterableIterator [number, MetaSlot]</h4>
<p>获得当前环境中所有已定义变量类型中的所有 Meta slot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{IterableIterator&lt;Type&gt;} tys
	 */</span>
	* getMetaSlotVars(tys) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> type <span class="hljs-keyword">of</span> tys) {
			<span class="hljs-keyword">let</span> type1 = type.zonk();
			<span class="hljs-keyword">yield</span>* type1.getMetaSlots();
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h4 id="gettypes-this-environment-iterableiterator-string">getTypes :: <em>this</em> Environment × → IterableIterator string</h4>
<p>获得当前环境中所有已定义变量类型中的所有自由 slot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{IterableIterator&lt;Type&gt;} tys
	 */</span>
	* getAllFreeSlots(tys) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> type <span class="hljs-keyword">of</span> tys) {
			<span class="hljs-keyword">let</span> type1 = type.zonk();
			<span class="hljs-keyword">yield</span>* type1.getFreeSlots();
		}
	}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rawNameToskolmeizedName</span>(<span class="hljs-params">u, n</span>) </span>{
	<span class="hljs-keyword">return</span> <span class="hljs-string">"."</span> + u + <span class="hljs-string">"."</span> + n;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rawNameOfskolmeizedName</span>(<span class="hljs-params">n</span>) </span>{
	<span class="hljs-keyword">return</span> n.replace(<span class="hljs-regexp">/^\.\d+\./</span>, <span class="hljs-string">""</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h3 id="-coercion-">约制子（Coercion）</h3>
<p>为了在类型检查的同时完成标记类型信息，我们使用约制子（Coercion）来处理项。约制子是一个编译时函数，它将一个项变换为已标记类型信息的形式。</p>
<h4 id="tag-type-term-term">tag :: Type → Term → Term</h4>
<p>为某个项附加类型信息</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tag</span>(<span class="hljs-params">type</span>) </span>{
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">form</span>) </span>{
		<span class="hljs-keyword">if</span> (form <span class="hljs-keyword">instanceof</span> Annotate) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(form.body, type);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(form, type);
		}
	};
}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h4 id="ctor-string-coercion-term-term">ctor :: string × Coercion → Term → Term</h4>
<p>约制某个复合类型项的构造器部分</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor</span>(<span class="hljs-params">x, coercion</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">form</span>) </span>{
		<span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> Var(<span class="hljs-string">"?"</span>);
		<span class="hljs-keyword">let</span> coerciedTmp = coercion(temp);
		<span class="hljs-keyword">if</span> (coerciedTmp <span class="hljs-keyword">instanceof</span> Annotate) {
			<span class="hljs-keyword">if</span> (form <span class="hljs-keyword">instanceof</span> Annotate) {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(form.body,
					form.type.subst(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">"?CTOR"</span> + x, coerciedTmp.type]])));
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(form,
					<span class="hljs-keyword">new</span> Composite(coerciedTmp.type, <span class="hljs-keyword">new</span> Slot(<span class="hljs-string">"?ARG"</span> + x)));
			}
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> coerciedTmp.subst(<span class="hljs-string">"?"</span>, form);
		}
	};
}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h4 id="arg-string-coercion-term-term">arg :: string × Coercion → Term → Term</h4>
<p>约制某个复合类型项的参数部分</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arg</span>(<span class="hljs-params">x, coercion</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">form</span>) </span>{
		<span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> Var(<span class="hljs-string">"?"</span>);
		<span class="hljs-keyword">let</span> coerciedTmp = coercion(temp);
		<span class="hljs-keyword">if</span> (coerciedTmp <span class="hljs-keyword">instanceof</span> Annotate) {
			<span class="hljs-keyword">if</span> (form <span class="hljs-keyword">instanceof</span> Annotate) {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(form.body,
					form.type.subst(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">"?ARG"</span> + x, coerciedTmp.type]])));
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(form,
					<span class="hljs-keyword">new</span> Composite(<span class="hljs-keyword">new</span> Slot(<span class="hljs-string">"?CTOR"</span> + x), coerciedTmp.type));
			}
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> coerciedTmp.subst(<span class="hljs-string">"?"</span>, form);
		}
	};
}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h4 id="buildgl-map-string-type-term-term">buildGL :: Map string Type × Term → Term</h4>
<p>构造一个 System-F 的 $\Lambda$ 项</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildGL</span>(<span class="hljs-params">m1, e</span>) </span>{
	<span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> Generic) {
		<span class="hljs-keyword">let</span> m2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(e.quantifiers);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> m1) {
			m2.add(k);
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Generic(<span class="hljs-built_in">Array</span>.from(m2), e.body);
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Generic(<span class="hljs-built_in">Array</span>.from(m1), e);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h2 id="-">第二部分，类型</h2>
<p>在我们的系统中，「类型」可以包含四种构造：</p>
<ul>
<li>Slot，表示一个被量化的名称，使用符号 $a$ 表示。</li>
<li>Primitive，表示一个原始类型，如 $\rm int$。</li>
<li>Composite，表示一个复合类型，如 $\rm list\ int$。函数类型是一种二级复合。</li>
<li>ForAll，表示一个多态量化 $\forall \overline\alpha. t$。</li>
</ul>
<p>此外在推理过程中，会涉及一种 Meta Slot，它代表一个尚未完全决议的类型。使用这种方式处理推理中的中间结果可见于 Jones 的另一篇文献，<em>Boxy Types: Inference for Higher-Rank Types and Impredicativity</em>。</p>
<p>我们将类型分为 $\sigma$, $\rho$, $\tau$ 三类，它们满足：</p>
<ul>
<li>$\tau \rightarrow \mathrm{Primitive}\ |\  a\ |\ \tau_1 \tau_2$</li>
<li>$\rho \rightarrow \tau\ |\ \sigma_1 \sigma_2$</li>
<li>$\sigma \rightarrow \forall \overline{a}.\rho$</li>
</ul>
<p>可以看出，$\sigma$ 类型为直接包含多态的类型，$\rho$ 类型则为嵌有多态结构的复合类型。在传统的 Hindley-Milner 系统中，$\rho$ 类型的第二种形式并不允许，它和 $\tau$ 类型完全等价。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span> </span>{
	<span class="hljs-keyword">constructor</span>() {}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h4 id="format-this-type-arrayform">format :: <em>this</em> Type → ArrayForm</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre>	format() {}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h4 id="getmetaslots-this-type-map-number-metaslot">getMetaSlots :: <em>this</em> Type → Map number MetaSlot</h4>
<p>获取当前类型中所有出现的 Meta slot。返回一个 id 到 meta slot 的映射。根据 Meta slot value 的定义，任何两个 id 相同的 Meta slot 都视作相等。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @returns {Map&lt;number, MetaSlot&gt;}
	 */</span>
	getMetaSlots() {
		<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>;
		<span class="hljs-keyword">this</span>._getMetaSlots(a);
		<span class="hljs-keyword">return</span> a;
	}
	_getMetaSlots(a) {}</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h4 id="getfreeslots-this-type-set-string">getFreeSlots :: <em>this</em> Type → Set string</h4>
<p>获取当前类型中所有出现的未绑定 slot。返回它们的名字组成的集合。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * Get all free slots
	 * @returns{Set&lt;string&gt;}
	 */</span>
	getFreeSlots() {
		<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>;
		<span class="hljs-keyword">let</span> bound = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>;
		<span class="hljs-keyword">this</span>._getFreeSlots(bound, a);
		<span class="hljs-keyword">return</span> a;
	}
	_getFreeSlots(bound, a) {}</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h4 id="getbinders-this-type-set-string">getBinders :: <em>this</em> Type → Set string</h4>
<p>获取当前类型中所有被 forall 使用的 slot 名字。返回其集合。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @returns{Set&lt;string&gt;}
	 */</span>
	getBinders() {
		<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>;
		<span class="hljs-keyword">this</span>._getBinders(a);
		<span class="hljs-keyword">return</span> a;
	}
	_getBinders() {}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h4 id="subst-this-type-map-string-type-type">subst :: <em>this</em> Type × Map string Type → Type</h4>
<p>根据 m 的要求，替换一些 slot 的内容。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Map&lt;string, Type&gt;} m
	 * @returns {Type}
	 */</span>
	subst(m) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h4 id="instantiate-this-type-environment-type">instantiate :: <em>this</em> Type × Environment → Type</h4>
<p>在环境 env 中，实例化当前的多态类型。它会去除顶层的 $\forall$ 符号。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Environment} env
	 * @returns {{type: Type, coercion: Function}}
	 */</span>
	instantiate(env) {
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">type</span>: <span class="hljs-keyword">this</span>,
			<span class="hljs-attr">coercion</span>: tag(<span class="hljs-keyword">this</span>)
		};
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h4 id="skolmeize-this-type-environment-map-map-string-slot-type-type-coercion-coercion-">skolmeize :: <em>this</em> Type × Environment → {map: Map string Slot, type: Type, coercion: Coercion}</h4>
<p>在当前环境 env 中，产生当前类型的一个斯科伦范式形式。它可以看作实例化的递归版本，会展开每一层的多态，同时会返回新产生的临时变量的表（这里使用一个名字到 Slot 的 Map 实现），以及一个约制项。我们不会展开复合类型的前件，避免错误地捕捉变量。此过程产生的类型必然保证：所有复合类型的协变端不包含任何的多态。</p>
<p>一个实例是：$\mathrm{skol}(\forall a.a\rightarrow(\forall b.b\rightarrow b))=\forall ab. a \rightarrow (b \rightarrow b)$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Environment} env
	 * @returns {{map: Map&lt;string, Slot&gt;, type: Type, coercion: Function}}
	 */</span>
	skolmeize(env) {
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">map</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),
			<span class="hljs-attr">type</span>: <span class="hljs-keyword">this</span>,
			<span class="hljs-attr">coercion</span>: tag(<span class="hljs-keyword">this</span>)
		};
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h4 id="generalize-this-type-environment-metaslotval-forall">generalize :: <em>this</em> Type × Environment × [MetaSlotVal] → ForAll</h4>
<p>在当前环境 env 中，根据 mvs 列表泛化当前类型。将返回一个多态类型。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Environment} env
	 * @param {Array&lt;MetaSlotVal&gt;} mvs
	 * @returns {ForAll}
	 */</span>
	generalize(env, mvs) {
		<span class="hljs-keyword">let</span> usedBinders = <span class="hljs-keyword">this</span>.getBinders();
		<span class="hljs-keyword">let</span> nRef = { <span class="hljs-attr">val</span>: <span class="hljs-number">0</span> };
		<span class="hljs-keyword">let</span> newBinders = [];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> slot <span class="hljs-keyword">of</span> mvs) {
			<span class="hljs-keyword">let</span> newBinder = <span class="hljs-keyword">new</span> Slot(generateBinder(nRef, usedBinders));
			slot.typeRef.val = newBinder;
			newBinders.push(newBinder);
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForAll(newBinders.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.name), <span class="hljs-keyword">this</span>.zonk());
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h4 id="zonk-this-type-environment-type">zonk :: <em>this</em> Type × Environment → Type</h4>
<p>消除掉当前类型中所有的 Meta Slot。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @returns {Type}
	 */</span>
	zonk() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h4 id="instsigmainfer-this-type-environment-type-type-coercion-coercion-">instSigmaInfer :: <em>this</em> Type × Environment → {type: Type, coercion: Coercion}</h4>
<p>在类型推理时，生成一个实例化的版本和对应的约制项。</p>
<p>INFER-INST: $\dfrac{}{\forall \overline a. \rho \le \sim [\overline{a\rightarrow\mathrm{fresh}}]\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @returns {{type: Type, coercion: Function}}
	 */</span>
	instSigmaInfer(env) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.instantiate(env);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h4 id="instsigmacheck-this-type-environment-type-coercion">instSigmaCheck :: <em>this</em> Type × Environment × Type → Coercion</h4>
<p>在类型推理时，检查本类型是否符合需求，返回一个约制项</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} expected
	 * @returns{Function}
	 */</span>
	instSigmaCheck(env, expected) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subsCheckRho(env, expected);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h4 id="subscheck-this-type-environment-type-coercion-br-subscheckrho-this-type-environment-type-coercion">subsCheck :: <em>this</em> Type × Environment × Type → Coercion <br> subsCheckRho :: <em>this</em> Type × Environment × Type → Coercion</h4>
<p>判断某个类型是否比另一个我们期待的类型更加「泛化」。返回一个约制项。
我们把它拆分成两个部分：$\rm subsCheck$ 和 $\rm subsCheckRho$，前者处理两个 $\sigma$ 类型，后者处理一个 $\sigma$ 类型和一个 $\rho$ 类型。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} that
	 * @returns{Function}
	 */</span>
	subsCheck(env, that) {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>$\sigma_1 \le \sigma_2$ 成立，当且仅当：</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">const</span> {<span class="hljs-attr">map</span>: skolTvs, <span class="hljs-attr">type</span>: rho2, <span class="hljs-attr">coercion</span>: f1} = that.skolmeize(env);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <ul>
<li>$\sigma_1 \le \rho, \forall \overline a. \rho = \mathrm{skol}(\sigma_2)$</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">const</span> f2 = <span class="hljs-keyword">this</span>.subsCheckRho(env, rho2);</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <ul>
<li><p>并且，$\sigma_1$ 的自由变量中，$\sigma_2$ 中的对应者没有被「提出来」</p>
<p>$\overline a \not\in \mathrm{free}(\sigma_1)$</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">const</span> escTvs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(env.getAllFreeSlots([<span class="hljs-keyword">this</span>]));
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> skolTvs) {
			<span class="hljs-keyword">if</span> (escTvs.has(rawNameOfskolmeizedName(k))) {
				<span class="hljs-keyword">throw</span> <span class="hljs-string">"Subsumption check failed"</span>
			}
		}
		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
			<span class="hljs-keyword">return</span> f1(buildGL(skolTvs.keys(), f2(x)));
		};
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>${\rm subsCheckRho}(\sigma, \rho)$ 将会检查是否 $\sigma$ 比 $\rho$ 更加泛化（$\sigma\le\rho$）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} that
	 * @returns{Function}
	 */</span>
	subsCheckRho(env, that) {
		<span class="hljs-keyword">if</span> (that <span class="hljs-keyword">instanceof</span> Composite) {
			<span class="hljs-keyword">const</span> [f1, a1] = unifyComposite(<span class="hljs-keyword">this</span>, env);
			<span class="hljs-keyword">return</span> subsCheckComposite(env, that.contravariant, f1, that.fn, a1, that.arg);
		} <span class="hljs-keyword">else</span> {
			unify(<span class="hljs-keyword">this</span>, that);
			<span class="hljs-keyword">return</span> tag(<span class="hljs-keyword">this</span>);
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <h4 id="subscheckcomposite-environment-boolean-type-type-type-type-coercion">subsCheckComposite :: Environment × boolean × Type × Type × Type × Type → Coercion</h4>
<p>复合类型的小前提检查，注意反变性。在这里我们限制任何复合类型的构造器部分是<strong>非变</strong>的，这样可以降低复杂性。对于协/反变性的更精细处理可以递归展开 f1/f2 的部分，然后分别处理每个参数。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subsCheckComposite</span>(<span class="hljs-params">env, contravariant, f1, f2, a1, a2</span>) </span>{
	<span class="hljs-keyword">const</span> tagf1 = f1.subsCheck(env, f2);
	<span class="hljs-keyword">let</span> tagf2;
	<span class="hljs-keyword">if</span> (contravariant) {
		tagf2 = a2.subsCheck(env, a1);
	} <span class="hljs-keyword">else</span> {
		tagf2 = a1.subsCheckRho(env, a2);
	}
	<span class="hljs-keyword">const</span> z = env.newVar(<span class="hljs-string">"S"</span>);
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
		<span class="hljs-keyword">return</span> ctor(z, tagf1)(arg(z, tagf2)(x));
	};
}</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h4 id="generatebinder-ref-number-set-string-string">generateBinder :: ref number × Set string → string</h4>
<p>获取新的名字，用于泛化过程中的重命名</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateBinder</span>(<span class="hljs-params">nRef, used</span>) </span>{
	nRef.val += <span class="hljs-number">1</span>;
	<span class="hljs-keyword">let</span> name = <span class="hljs-string">"t"</span> + nRef.val;
	<span class="hljs-keyword">while</span> (used.has(name)) {
		nRef.val += <span class="hljs-number">1</span>;
		name = <span class="hljs-string">"t"</span> + nRef.val;
	}
	<span class="hljs-keyword">return</span> name;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h3 id="-">基本类型</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Primitive</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>{
	<span class="hljs-comment">/**
	 * @param {string} name
	 */</span>
	<span class="hljs-keyword">constructor</span>(name) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.name = name;
	}
	format() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.yellow;
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h3 id="-a-">限制的类型变量，$a$</h3>
<p>Slot 可能有两种来源：</p>
<ul>
<li>在外面某个 $\forall$ 之后出现</li>
<li>由斯科伦化产生</li>
</ul>
<p>我们使用名字区分之，名称以 <code>.</code> 开头的都是由斯科伦化产生产生的 Slot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Slot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>{
	<span class="hljs-comment">/**
	 * @param {string} name
	 */</span>
	<span class="hljs-keyword">constructor</span>(name) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.name = name;
	}
	format() {
		<span class="hljs-keyword">return</span> (<span class="hljs-string">"'"</span> + <span class="hljs-keyword">this</span>.name).green;
	}
	_getFreeSlots(bound, a) {
		<span class="hljs-keyword">if</span> (!bound.has(<span class="hljs-keyword">this</span>.name) &amp;&amp; !a.has(<span class="hljs-keyword">this</span>.name)) {
			a.add(<span class="hljs-keyword">this</span>.name);
		}
	}
	subst(m) {
		<span class="hljs-keyword">if</span> (m.has(<span class="hljs-keyword">this</span>.name)) {
			<span class="hljs-keyword">return</span> m.get(<span class="hljs-keyword">this</span>.name);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		}
	}
	isSkolem() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name[<span class="hljs-number">0</span>] === <span class="hljs-string">"."</span>;
	}
	equalTo(that) {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isSkolem() &amp;&amp; that.isSkolem()) {
			<span class="hljs-keyword">return</span> rawNameOfskolmeizedName(<span class="hljs-keyword">this</span>.name) === rawNameOfskolmeizedName(that.name);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isSkolem() &amp;&amp; !that.isSkolem()) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name === that.name;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h3 id="-sigma_1-sigma_2-">复合类型，$\sigma_1 \sigma_2$</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>复合类型由三个部分构成：</p>
<ul>
<li>构造器部分，<em>fn</em></li>
<li>参数部分，<em>arg</em></li>
<li>协变/反变性，<em>contravariant</em></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Type} fn
	 * @param {Type} arg
	 * @param {boolean} contravariant
	 */</span>
	<span class="hljs-keyword">constructor</span>(fn, arg, contravariant) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.fn = fn;
		<span class="hljs-keyword">this</span>.arg = arg;
		<span class="hljs-keyword">this</span>.contravariant = contravariant || <span class="hljs-literal">false</span>;
	}
	format() {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fn <span class="hljs-keyword">instanceof</span> Composite) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fn.format().concat([ <span class="hljs-keyword">this</span>.arg.format()]);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.fn.format(), <span class="hljs-keyword">this</span>.arg.format()];
		}
	}
	_getMetaSlots(a) {
		<span class="hljs-keyword">this</span>.fn._getMetaSlots(a);
		<span class="hljs-keyword">this</span>.arg._getMetaSlots(a);
	}
	_getFreeSlots(bound, a) {
		<span class="hljs-keyword">this</span>.fn._getFreeSlots(bound, a);
		<span class="hljs-keyword">this</span>.arg._getFreeSlots(bound, a);
	}
	_getBinders(a) {
		<span class="hljs-keyword">this</span>.fn._getBinders(a);
		<span class="hljs-keyword">this</span>.arg._getBinders(a);
	}
	subst(m) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Composite(<span class="hljs-keyword">this</span>.fn.subst(m), <span class="hljs-keyword">this</span>.arg.subst(m), <span class="hljs-keyword">this</span>.contravariant);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>复合类型的斯科伦化需要小心地处理其参数部分：</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	skolmeize(env) {
		<span class="hljs-keyword">let</span> {<span class="hljs-attr">map</span>: m1, <span class="hljs-attr">type</span>: t1, <span class="hljs-attr">coercion</span>: f1} = <span class="hljs-keyword">this</span>.fn.skolmeize(env);
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contravariant) {</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <ul>
<li>如果这个类型是反变的，保留其 arg 部分；</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">const</span> argtype = <span class="hljs-keyword">this</span>.arg;
			<span class="hljs-keyword">const</span> skolRho = <span class="hljs-keyword">new</span> Composite(t1, argtype, <span class="hljs-keyword">this</span>.contravariant);
			<span class="hljs-keyword">const</span> z = env.newVar(<span class="hljs-string">"S"</span>);
			<span class="hljs-keyword">return</span> {
				<span class="hljs-attr">map</span>: m1,
				<span class="hljs-attr">type</span>: skolRho,
				<span class="hljs-attr">coercion</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
					<span class="hljs-keyword">if</span> (m1.size) {
						<span class="hljs-keyword">return</span> buildGL(m1.keys(), ctor(z, f1)(arg(z, tag(argtype))(x)));
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> ctor(z, f1)(arg(z, tag(argtype))(x));
					}
				}
			};
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <ul>
<li>如果这个类型是协变的，展开其 arg 部分。</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">let</span> {<span class="hljs-attr">map</span>: m2, <span class="hljs-attr">type</span>: t2, <span class="hljs-attr">coercion</span>: f2} = <span class="hljs-keyword">this</span>.arg.skolmeize(env);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> m1.entries()) {
				m2.set(k, v);
			}
			<span class="hljs-keyword">const</span> skolRho = <span class="hljs-keyword">new</span> Composite(t1, t2, <span class="hljs-keyword">this</span>.contravariant);
			<span class="hljs-keyword">const</span> z = env.newVar(<span class="hljs-string">"R"</span>);
			<span class="hljs-keyword">return</span> {
				<span class="hljs-attr">map</span>: m2,
				<span class="hljs-attr">type</span>: skolRho,
				<span class="hljs-attr">coercion</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
					<span class="hljs-keyword">if</span> (m2.size) {
						<span class="hljs-keyword">return</span> buildGL(m2.keys(), ctor(z, f1)(arg(z, f2)(x)));
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> ctor(z, f1)(arg(z, f2)(x));
					}
				}
			};
		}
	}
	zonk() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Composite(<span class="hljs-keyword">this</span>.fn.zonk(), <span class="hljs-keyword">this</span>.arg.zonk(), <span class="hljs-keyword">this</span>.contravariant);
	}
	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} that
	 */</span>
	subsCheckRho(env, that) {
		<span class="hljs-keyword">const</span> [f2, a2] = unifyComposite(that, env);
		<span class="hljs-keyword">return</span> subsCheckComposite(env, <span class="hljs-keyword">this</span>.contravariant, <span class="hljs-keyword">this</span>.fn, f2, <span class="hljs-keyword">this</span>.arg, a2);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h3 id="-forall-overline-a-rho-">多态类型，$\forall \overline a. \rho$</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForAll</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>{
	<span class="hljs-comment">/**
	 * @param {Array&lt;string&gt;} quantifiers
	 * @param {Type} body
	 */</span>
	<span class="hljs-keyword">constructor</span>(quantifiers, body) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.quantifiers = quantifiers;
		<span class="hljs-keyword">this</span>.body = body;
	}
	format() {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.quantifiers.length) {
			<span class="hljs-keyword">return</span> [<span class="hljs-string">"forall"</span>.blue.bold,
				<span class="hljs-keyword">this</span>.quantifiers.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-keyword">new</span> Slot(x).format()), <span class="hljs-keyword">this</span>.body.format()];
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.body.format();
		}
	}
	_getMetaSlots(a) {
		<span class="hljs-keyword">this</span>.body._getMetaSlots(a);
	}
	_getFreeSlots(bound, a) {
		<span class="hljs-keyword">const</span> b1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(bound);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> q <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.quantifiers) {
			b1.add(q);
		}
		<span class="hljs-keyword">this</span>.body._getFreeSlots(b1, a);
	}
	_getBinders(a) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> q <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.quantifiers) {
			a.add(q);
		}
		<span class="hljs-keyword">this</span>.body._getBinders(a);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>多态类型进行替换的时候，需要从映射 m 中删掉其量化子 $\overline a$ 包含的项目。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	subst(m) {
		<span class="hljs-keyword">let</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(m);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> q <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.quantifiers) {
			m1.delete(q);
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForAll(<span class="hljs-keyword">this</span>.quantifiers, <span class="hljs-keyword">this</span>.body.subst(m1));
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>实例化时，创建一个量化子 $\overline a$ 到「新变量」的映射，然后返回其内容经过替换时的结果。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	instantiate(env) {
		<span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> q <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.quantifiers) {
			m.set(q, <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal()));
		}
		<span class="hljs-keyword">const</span> rho = <span class="hljs-keyword">this</span>.body.subst(m);
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">type</span>: rho,
			<span class="hljs-attr">coercion</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
				<span class="hljs-keyword">if</span> (m.size) {
					<span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> Invoke &amp;&amp; x.fn <span class="hljs-keyword">instanceof</span> Inst) {
						<span class="hljs-keyword">let</span> m1 = x.fn.args;
						<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> m.entries()) {
							m1.set(k, v);
						}
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Inst(x.arg, m1);
					} <span class="hljs-keyword">else</span> {
						<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Inst(x, m);
					}
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> x;
				}
			}
		};
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>多态类型的深斯科伦化会合并内外两层的变量表。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Environment} env
	 */</span>
	skolmeize(env) {
		<span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
		<span class="hljs-keyword">let</span> mSub = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> q <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.quantifiers) {
			<span class="hljs-keyword">const</span> sv = env.newSkolemVariable(q);
			<span class="hljs-keyword">const</span> ss = <span class="hljs-keyword">new</span> Slot(sv);
			m.set(sv, ss);
			mSub.set(q, ss);
		}
		<span class="hljs-keyword">let</span> {<span class="hljs-attr">map</span>: mBody, <span class="hljs-attr">type</span>: t1, <span class="hljs-attr">coercion</span>: f} = <span class="hljs-keyword">this</span>.body.subst(mSub).skolmeize(env);
		<span class="hljs-keyword">let</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(mBody);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> m.entries()) {
			m1.set(k, v);
		}
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">map</span>: m1,
			<span class="hljs-attr">type</span>: t1,
			<span class="hljs-attr">coercion</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
				<span class="hljs-keyword">const</span> mRev = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Array</span>.from(mSub).map(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> [v.name, <span class="hljs-keyword">new</span> Slot(k)]));
				<span class="hljs-keyword">if</span> (m.size) {
					<span class="hljs-keyword">return</span> buildGL(mSub.keys(), <span class="hljs-keyword">new</span> Inst(f(x), mRev));
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> f(x);
				}
			}
		};
	}

	zonk() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForAll(<span class="hljs-keyword">this</span>.quantifiers, <span class="hljs-keyword">this</span>.body.zonk());
	}
	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} that
	 */</span>
	subsCheckRho(env, that) {
		<span class="hljs-keyword">let</span> {<span class="hljs-attr">type</span>:rho1, <span class="hljs-attr">coercion</span>:t1} = <span class="hljs-keyword">this</span>.instantiate(env);
		<span class="hljs-keyword">const</span> f = rho1.subsCheckRho(env, that);
		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
			<span class="hljs-keyword">return</span> f(t1(x));
		};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h3 id="meta-slot-">Meta Slot，推理过程中的未决议类型</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaSlot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Type</span> </span>{
	<span class="hljs-comment">/**
	 * @param {MetaSlotVal} arg
	 */</span>
	<span class="hljs-keyword">constructor</span>(arg) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.arg = arg;
	}
	format() {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.arg) {
			<span class="hljs-keyword">return</span> (<span class="hljs-string">"?"</span> + <span class="hljs-keyword">this</span>.arg.id).red.bold;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> (<span class="hljs-string">"??"</span>).red.bold;
		}
	}
	_getMetaSlots(a) {
		<span class="hljs-keyword">if</span> (!a.has(<span class="hljs-keyword">this</span>.arg.id)) {
			a.set(<span class="hljs-keyword">this</span>.arg.id, <span class="hljs-keyword">this</span>.arg);
		}
	}
	zonk() {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.arg &amp;&amp; <span class="hljs-keyword">this</span>.arg.typeRef.val) {
			<span class="hljs-keyword">let</span> t1 = <span class="hljs-keyword">this</span>.arg.typeRef.val.zonk();
			<span class="hljs-keyword">this</span>.arg.typeRef.val = t1;
			<span class="hljs-keyword">return</span> t1;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h3 id="metaslotval-metaslot-">MetaSlotVal: MetaSlot 的值</h3>
<p>MetaSlotVal 包含两个字段，编号 id 和 typeRef，一个对类型的引用。两个 MetaSlotVal 的 id 相同即视为相等。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaSlotVal</span> </span>{
	<span class="hljs-comment">/**
	 * @param {number} id
	 * @param {{val:Type}} typeRef
	 */</span>
	<span class="hljs-keyword">constructor</span>(id, typeRef) {
		<span class="hljs-keyword">this</span>.id = id;
		<span class="hljs-keyword">this</span>.typeRef = typeRef;
	}
	equalTo(that) {
		<span class="hljs-keyword">return</span> that &amp;&amp; that <span class="hljs-keyword">instanceof</span> MetaSlotVal &amp;&amp; that.id === <span class="hljs-keyword">this</span>.id;
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <h2 id="-">第三部分，合一</h2>

            </div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h3 id="unify-type-type-boolean">unify :: type × type → boolean</h3>
<p>尝试合一两个类型，成功返回 true，否则报错。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @param {Type} t1
 * @param {Type} t2
 * @returns {boolean}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unify</span>(<span class="hljs-params">t1, t2</span>) </span>{
	<span class="hljs-keyword">if</span> (badtype(t1) || badtype(t2)) <span class="hljs-keyword">throw</span> <span class="hljs-string">"Should not be here."</span>
	<span class="hljs-keyword">if</span> (t1 <span class="hljs-keyword">instanceof</span> Slot &amp;&amp; t2 <span class="hljs-keyword">instanceof</span> Slot &amp;&amp; t1.equalTo(t2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">if</span> (t1 <span class="hljs-keyword">instanceof</span> MetaSlot &amp;&amp; t2 <span class="hljs-keyword">instanceof</span> MetaSlot &amp;&amp; t1.arg.equalTo(t2.arg)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">if</span> (t1 <span class="hljs-keyword">instanceof</span> MetaSlot) <span class="hljs-keyword">return</span> unifyMetaSlot(t1.arg, t2);
	<span class="hljs-keyword">if</span> (t2 <span class="hljs-keyword">instanceof</span> MetaSlot) <span class="hljs-keyword">return</span> unifyMetaSlot(t2.arg, t1);
	<span class="hljs-keyword">if</span> (t1 <span class="hljs-keyword">instanceof</span> Composite &amp;&amp; t2 <span class="hljs-keyword">instanceof</span> Composite) {
		unify(t1.fn, t2.fn);
		unify(t2.arg, t2.arg);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}
	<span class="hljs-keyword">if</span> (t1 <span class="hljs-keyword">instanceof</span> Primitive &amp;&amp; t2 <span class="hljs-keyword">instanceof</span> Primitive &amp;&amp; t1.name === t2.name) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Cannot unify <span class="hljs-subst">${t1.format()}</span> with <span class="hljs-subst">${t2.format()}</span>`</span>)
}
<span class="hljs-comment">/**
 * @param {Type} t
 * @returns {boolean}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">badtype</span>(<span class="hljs-params">t</span>) </span>{
	<span class="hljs-keyword">return</span> t <span class="hljs-keyword">instanceof</span> Slot &amp;&amp; !t.isSkolem();
}</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <h3 id="unifymetaslot-metaslotval-type-boolean">unifyMetaSlot :: MetaSlotVal × Type → boolean</h3>
<p>Meta slot 的合一，一般情况</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @param {MetaSlotVal} msv
 * @param {Type} ty
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unifyMetaSlot</span>(<span class="hljs-params">msv, ty</span>) </span>{
	<span class="hljs-keyword">if</span> (msv.typeRef.val) {
		<span class="hljs-keyword">return</span> unify(msv.typeRef.val, ty);
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> unifyUnbound(msv, ty);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <h3 id="unifyunbound-metaslotval-type-boolean">unifyUnbound :: MetaSlotVal × Type → boolean</h3>
<p>Meta slot 的合一，未绑定情况</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @param {MetaSlotVal} msv
 * @param {Type} ty
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unifyUnbound</span>(<span class="hljs-params">msv, ty</span>) </span>{
	<span class="hljs-keyword">if</span> (ty <span class="hljs-keyword">instanceof</span> MetaSlot) {
		<span class="hljs-keyword">let</span> msv2 = ty.arg;
		<span class="hljs-keyword">if</span> (msv2.typeRef.val) {
			<span class="hljs-keyword">return</span> unify(<span class="hljs-keyword">new</span> MetaSlot(msv), msv2.typeRef.val);
		} <span class="hljs-keyword">else</span> {
			msv.typeRef.val = ty;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		}
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">let</span> msvs2 = ty.getMetaSlots();
		<span class="hljs-keyword">if</span> (msvs2.has(msv.id)) {
			<span class="hljs-keyword">throw</span> <span class="hljs-string">"Recursive Type."</span>
		} <span class="hljs-keyword">else</span> {
			msv.typeRef.val = ty;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <h3 id="unifyfun-type-environment-boolean">unifyFun :: Type × Environment → boolean</h3>
<p>合一类型到函数</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @param {Type} type
 * @param {Environment} env
 * @returns {[Type, Type]}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unifyFun</span>(<span class="hljs-params">type, env</span>) </span>{
	<span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> Composite
		&amp;&amp; type.fn <span class="hljs-keyword">instanceof</span> Composite
		&amp;&amp; type.fn.fn <span class="hljs-keyword">instanceof</span> Primitive
		&amp;&amp; type.fn.fn.name === <span class="hljs-string">"-&gt;"</span>) {
		<span class="hljs-keyword">return</span> [type.fn.arg, type.arg];
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">const</span> argMs = <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal());
		<span class="hljs-keyword">const</span> resMs = <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal());
		unify(FunctionType(argMs, resMs), type);
		<span class="hljs-keyword">return</span> [argMs, resMs];
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <h3 id="functiontype-type-type-type">FunctionType :: Type × Type → Type</h3>
<p>构造一个函数类型</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FunctionType</span>(<span class="hljs-params">arg, body</span>) </span>{
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Composite(<span class="hljs-keyword">new</span> Composite(<span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"-&gt;"</span>), arg, <span class="hljs-literal">true</span>), body, <span class="hljs-literal">false</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <h3 id="unifycomposite-type-environment-boolean">unifyComposite :: Type × Environment → boolean</h3>
<p>合一类型到任意复合类型</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @param {Type} type
 * @param {Environment} env
 * @returns {[Type, Type]}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unifyComposite</span>(<span class="hljs-params">type, env</span>) </span>{
	<span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> Composite) {
		<span class="hljs-keyword">return</span> [type.fn, type.arg];
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">const</span> argMs = <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal());
		<span class="hljs-keyword">const</span> resMs = <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal());
		unify(<span class="hljs-keyword">new</span> Composite(argMs, resMs), type);
		<span class="hljs-keyword">return</span> [argMs, resMs];
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <h2 id="-">第四部分，主推理算法</h2>
<p>由于高阶类型的介入，Damas-Hindley-Milner 系统中的单一「推理」方法需要拆分为一对方法，<code>infer</code> 和 <code>check</code>；它们会再根据所处理的类型（$\sigma$ 或者 $\rho$ 类型），再各自进行拆分，因此最终得到四个方法：<code>inferRho</code>, <code>checkRho</code>, <code>inferSigma</code>, <code>checkSigma</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-keyword">constructor</span>() {}
	isAtomic() {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>format :: <em>this</em> → ArrayForm</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	format() {}</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <h4 id="subst-this-term-string-term-term">subst :: <em>this</em> Term × string × Term → Term</h4>
<p>替换一个变量名为一个其他形式。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}
	<span class="hljs-comment">/**
	 * @param{Map&lt;string, Type&gt;} m
	 */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h4 id="checkrho-this-term-environment-type-tagged">checkRho :: <em>this</em> Term × Environment × Type → Tagged</h4>
<p>在环境 env 中检查当前表达式是否符合 $\rho$ 类型 type</p>
<p>$\Gamma\vdash t : \rho$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Environment} env
	 * @param {Type} type
	 * @returns {Term}
	 */</span>
	_checkRho(env, type) {}
	checkRho(env, type) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._checkRho(env, type);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h4 id="inferrho-this-term-environment-type-type-tagged-tagged-">inferRho :: <em>this</em> Term × Environment → {type: Type, tagged: Tagged}</h4>
<p>在环境 env 中推理，尝试得到 $\rho$ 类型（或者报错）</p>
<p>$\Gamma\vdash t :\sim \rho$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Environment} env
	 * @returns {{tagged: Term, type: Type}}
	 */</span>
	_inferRho(env) {}
	inferRho(env) {
		<span class="hljs-keyword">const</span> t = <span class="hljs-keyword">this</span>._inferRho(env);
		<span class="hljs-keyword">if</span> (!t) <span class="hljs-keyword">throw</span> <span class="hljs-string">"Cannot decide type"</span>
		<span class="hljs-keyword">return</span> t;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <h4 id="checksigma-this-term-environment-type-tagged">checkSigma :: <em>this</em> Term × Environment × Type → Tagged</h4>
<p>在环境 env 中检查当前表达式是否符合 $\sigma$ 类型 type。返回一个带 $Lambda$ 的约制。</p>
<p>CHECK-SIGMA: $\dfrac{\overline a \not\in \mathrm{free}(\Gamma)\quad \Gamma\vdash t:\rho\quad \forall\overline a.\rho = \mathrm{skol}(\sigma)}{\Gamma\vdash^* t:\sigma}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param {Environment} env
	 * @param {Type} sigma
	 * @returns {Term}
	 */</span>
	checkSigma(env, type) {
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">map</span>: mvs, <span class="hljs-attr">type</span>: rho, <span class="hljs-attr">coercion</span>: f} = type.skolmeize(env);
		<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">this</span>.checkRho(env, rho);
		<span class="hljs-keyword">const</span> envTys = env.getTypes();
		<span class="hljs-keyword">const</span> escTvs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(env.getAllFreeSlots(envTys));
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [name, slot] <span class="hljs-keyword">of</span> mvs) {
			<span class="hljs-keyword">if</span> (escTvs.has(rawNameOfskolmeizedName(name))) {
				<span class="hljs-keyword">throw</span> <span class="hljs-string">"Type is not polymorphic enough"</span>
			}
		}
		<span class="hljs-keyword">if</span> (mvs.size) {
			<span class="hljs-keyword">return</span> f(buildGL(mvs.keys(), e));
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> e;
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <h4 id="infersigma-this-term-environment-type-type-tagged-tagged-">inferSigma :: <em>this</em> Term × Environment → {type: Type, tagged: Tagged}</h4>
<p>在环境 env 中推理，尝试得到 $\sigma$ 类型（或者报错）以及对应的带 $Lambda$ 的约制。</p>
<p>INFER-SIGMA: $\dfrac{\overline a = \mathrm{free}(\rho)-\mathrm{free}(\Gamma)\quad \Gamma\vdash t:\sim \rho}{\Gamma\vdash^* t:\sim\forall\overline a.\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @returns {{tagged: Term, type: Type}}
	 */</span>
	inferSigma(env) {
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: expTy, tagged} = <span class="hljs-keyword">this</span>.inferRho(env);
		<span class="hljs-keyword">const</span> envTys = env.getTypes();
		<span class="hljs-keyword">const</span> envMsvs = env.getMetaSlotVars(envTys);
		<span class="hljs-keyword">const</span> resMsvs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(env.getMetaSlotVars([expTy]));
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [id, v] <span class="hljs-keyword">of</span> envMsvs) {
			resMsvs.delete(id);
		}
		<span class="hljs-keyword">const</span> polyTy = expTy.generalize(env, <span class="hljs-built_in">Array</span>.from(resMsvs.values()));
		<span class="hljs-keyword">if</span> (polyTy.quantifiers.length) {
			<span class="hljs-keyword">return</span> {
				<span class="hljs-attr">type</span>: polyTy,
				<span class="hljs-attr">tagged</span>: buildGL(polyTy.quantifiers, tagged)
			};
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> {
				<span class="hljs-attr">type</span>: polyTy,
				<span class="hljs-attr">tagged</span>: tagged
			};
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h3 id="-">直接量</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Literal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {any} n
	 */</span>
	<span class="hljs-keyword">constructor</span>(n) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.lit = n;
	}
	isAtomic() {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}
	format() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lit + <span class="hljs-string">""</span>;
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>CHECK-LIT: $\dfrac{}{\Gamma\vdash \iota:\mathrm{literalTypeOf}(\iota)}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	_checkRho(env, exp) {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.lit === <span class="hljs-string">"number"</span>) {
			<span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"int"</span>).instSigmaCheck(env, exp);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.lit === <span class="hljs-string">"string"</span>) {
			<span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"str"</span>).instSigmaCheck(env, exp);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.lit === <span class="hljs-string">"boolean"</span>) {
			<span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"boolean"</span>).instSigmaCheck(env, exp);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"unit"</span>).instSigmaCheck(env, exp);
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>INFER-LIT: $\dfrac{}{\Gamma\vdash \iota:\sim\mathrm{literalTypeOf}(\iota)}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	_inferRho(env) {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.lit === <span class="hljs-string">"number"</span>) {
			<span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"int"</span>).instSigmaInfer(env).type, <span class="hljs-attr">tagged</span>: <span class="hljs-keyword">this</span>};
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.lit === <span class="hljs-string">"string"</span>) {
			<span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"str"</span>).instSigmaInfer(env).type, <span class="hljs-attr">tagged</span>: <span class="hljs-keyword">this</span>};
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.lit === <span class="hljs-string">"boolean"</span>) {
			<span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"boolean"</span>).instSigmaInfer(env).type, <span class="hljs-attr">tagged</span>: <span class="hljs-keyword">this</span>};
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: <span class="hljs-keyword">new</span> Primitive(<span class="hljs-string">"unit"</span>).instSigmaInfer(env).type, <span class="hljs-attr">tagged</span>: <span class="hljs-keyword">this</span>};
		}
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <h3 id="-">变量</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Var</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {string} name
	 */</span>
	<span class="hljs-keyword">constructor</span>(name) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.name = name;
	}
	isAtomic() {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}
	format() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">if</span> (id === <span class="hljs-keyword">this</span>.name) <span class="hljs-keyword">return</span> replacement; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>CHECK-VAR: $\dfrac{\sigma\le\rho}{\Gamma, x:\sigma\vdash x:\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	_checkRho(env, expected) {
		<span class="hljs-keyword">const</span> f = env.lookup(<span class="hljs-keyword">this</span>.name).instSigmaCheck(env, expected);
		<span class="hljs-keyword">return</span> f(<span class="hljs-keyword">this</span>);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>INFER-VAR: $\dfrac{\sigma\le\sim\rho}{\Gamma, x:\sigma\vdash x:\sim\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	_inferRho(env) {
		<span class="hljs-keyword">const</span> {type, <span class="hljs-attr">coercion</span>: f} = env.lookup(<span class="hljs-keyword">this</span>.name).instSigmaInfer(env);
		<span class="hljs-keyword">return</span> {type, <span class="hljs-attr">tagged</span>: f(<span class="hljs-keyword">this</span>)};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <h3 id="-">函数调用</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoke</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {Term} fn
	 * @param {Term} arg
	 */</span>
	<span class="hljs-keyword">constructor</span>(fn, arg) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.fn = fn;
		<span class="hljs-keyword">this</span>.arg = arg;
	}
	format() {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fn <span class="hljs-keyword">instanceof</span> Invoke) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fn.format().concat([<span class="hljs-keyword">this</span>.arg.format()]);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> [<span class="hljs-keyword">this</span>.fn.format(), <span class="hljs-keyword">this</span>.arg.format()];
		}
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Invoke(<span class="hljs-keyword">this</span>.fn.subst(id, replacement),
			<span class="hljs-keyword">this</span>.arg.subst(id, replacement));
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>CHECK-APP: $\dfrac{\Gamma\vdash t:\sim(\sigma \rightarrow \sigma’)\quad \Gamma\vdash^*u:\sigma\quad \sigma’\le\rho’}{\Gamma\vdash t\ u : \rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	_checkRho(env, expected) {
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: funTy, <span class="hljs-attr">tagged</span>: e1} = <span class="hljs-keyword">this</span>.fn.inferRho(env);
		<span class="hljs-keyword">const</span> [argTy, resTy] = unifyFun(funTy, env);
		<span class="hljs-keyword">const</span> e2 = <span class="hljs-keyword">this</span>.arg.checkSigma(env, argTy);
		<span class="hljs-keyword">const</span> f = resTy.instSigmaCheck(env, expected);
		<span class="hljs-keyword">return</span> f(<span class="hljs-keyword">new</span> Invoke(e1, e2));
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>INFER-APP: $\dfrac{\Gamma\vdash t:\sim(\sigma \rightarrow \sigma’)\quad\Gamma\vdash^* u:\sigma\quad \sigma’\le\sim\rho’}{\Gamma\vdash t\ u :\sim \rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	_inferRho(env) {
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: funTy, <span class="hljs-attr">tagged</span>: e1} = <span class="hljs-keyword">this</span>.fn.inferRho(env);
		<span class="hljs-keyword">const</span> [argTy, resTy] = unifyFun(funTy, env);
		<span class="hljs-keyword">const</span> e2 = <span class="hljs-keyword">this</span>.arg.checkSigma(env, argTy);
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: t, <span class="hljs-attr">coercion</span>: f} = resTy.instSigmaInfer(env);
		<span class="hljs-keyword">return</span> {<span class="hljs-attr">type</span>: t, <span class="hljs-attr">tagged</span>: f(<span class="hljs-keyword">new</span> Invoke(e1, e2))};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h3 id="-">函数抽象</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lambda</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {string} param
	 * @param {Term} body
	 */</span>
	<span class="hljs-keyword">constructor</span>(param, body) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.param = param;
		<span class="hljs-keyword">this</span>.body = body;
	}
	format() {
		<span class="hljs-keyword">return</span> [<span class="hljs-string">"λ"</span>.yellow.bold, <span class="hljs-keyword">this</span>.param, <span class="hljs-keyword">this</span>.body.format()];
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">if</span> (id != <span class="hljs-keyword">this</span>.param) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Lambda(<span class="hljs-keyword">this</span>.param, <span class="hljs-keyword">this</span>.body.subst(id, replacement));
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>CHECK-LAM: $\dfrac{\Gamma, x:\sigma_x\vdash^* t:\sigma_t}{\Gamma\vdash(\lambda\ x.t):\sigma_x\rightarrow\sigma_t}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} expected
	 */</span>
	_checkRho(env, expected) {
		<span class="hljs-keyword">const</span> [varTy, bodyTy] = unifyFun(expected, env);
		<span class="hljs-keyword">const</span> env1 = env.extend(<span class="hljs-keyword">this</span>.param, varTy);
		<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">this</span>.body.checkRho(env1, bodyTy); <span class="hljs-comment">// bodyTy is always a Rho-type.</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotatedLambda(<span class="hljs-keyword">this</span>.param, varTy, e);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>INFER-LAM: $\dfrac{\Gamma, x:\tau\vdash t:\sim\rho}{\Gamma\vdash(\lambda\ x.t):\sim\tau\rightarrow\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @returns{Type} 
	 */</span>
	_inferRho(env) {
		<span class="hljs-keyword">const</span> varTy = <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal());
		<span class="hljs-keyword">const</span> env1 = env.extend(<span class="hljs-keyword">this</span>.param, varTy);
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: bodyTy, <span class="hljs-attr">tagged</span>: e} = <span class="hljs-keyword">this</span>.body.inferRho(env1);
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">type</span>: FunctionType(varTy, bodyTy),
			<span class="hljs-attr">tagged</span>: <span class="hljs-keyword">new</span> AnnotatedLambda(<span class="hljs-keyword">this</span>.param, varTy, e)
		};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <h3 id="-">标记了参数类型的函数抽象</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotatedLambda</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {string} param
	 * @param {Type} type
	 * @param {Term} body
	 */</span>
	<span class="hljs-keyword">constructor</span>(param, type, body) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.param = param;
		<span class="hljs-keyword">this</span>.type = type;
		<span class="hljs-keyword">this</span>.body = body;
	}
	format() {
		<span class="hljs-keyword">return</span> [<span class="hljs-string">"λ"</span>.yellow.bold, [<span class="hljs-string">"::"</span>, <span class="hljs-keyword">this</span>.param, <span class="hljs-keyword">this</span>.type.zonk().format()], <span class="hljs-keyword">this</span>.body.format()];
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">if</span> (id != <span class="hljs-keyword">this</span>.param) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotatedLambda(<span class="hljs-keyword">this</span>.param, <span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.body.subst(id, replacement));
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>CHECK-ALAM: $\dfrac{\sigma_a\le\sigma_x\quad\Gamma, x:\sigma_x\vdash^* t:\sigma_t}{\Gamma\vdash(\lambda(x:\sigma_x).t):\sigma_a\rightarrow\sigma_t}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} expected
	 */</span>
	_checkRho(env, expected) {
		<span class="hljs-keyword">const</span> [varTy, bodyTy] = unifyFun(expected, env);
		<span class="hljs-keyword">const</span> f = varTy.subsCheck(<span class="hljs-keyword">this</span>.type);
		<span class="hljs-keyword">const</span> env1 = env.extend(<span class="hljs-keyword">this</span>.param, varTy);
		<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">this</span>.body.checkRho(env1, bodyTy);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnnotatedLambda(<span class="hljs-keyword">this</span>.param, varTy,
			e.subst(<span class="hljs-keyword">this</span>.param, <span class="hljs-keyword">new</span> Invoke(f, <span class="hljs-keyword">new</span> Var(<span class="hljs-keyword">this</span>.param))));
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>INFER-ALAM: $\dfrac{\Gamma, x:\sigma\vdash t:\sim\rho}{\Gamma\vdash(\lambda(x:\sigma).t):\sim\sigma\rightarrow\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @returns{Type} 
	 */</span>
	_inferRho(env) {
		<span class="hljs-keyword">const</span> env1 = env.extend(<span class="hljs-keyword">this</span>.param, <span class="hljs-keyword">this</span>.type);
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: bodyTy, <span class="hljs-attr">tagged</span>: e} = <span class="hljs-keyword">this</span>.body.inferRho(env1);
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">type</span>: FunctionType(<span class="hljs-keyword">this</span>.type, bodyTy),
			<span class="hljs-attr">tagged</span>: <span class="hljs-keyword">new</span> AnnotatedLambda(<span class="hljs-keyword">this</span>.param, <span class="hljs-keyword">this</span>.type, e)
		};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <h3 id="-let-">非递归 Let 绑定</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Let</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {Array&lt;{name: string, bind: Term}&gt;} terms
	 * @param {Term} body
	 */</span>
	<span class="hljs-keyword">constructor</span>(terms, body) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.terms = terms;
		<span class="hljs-keyword">this</span>.body = body;
	}
	format() {
		<span class="hljs-keyword">return</span> [<span class="hljs-string">"let"</span>.yellow.bold].concat(
			<span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function">(<span class="hljs-params">{name, type, bind}</span>) =&gt;</span> type
				? [<span class="hljs-string">"="</span>, [<span class="hljs-string">"::"</span>, name, type.format()], bind.format()]
				: [<span class="hljs-string">"="</span>, name, bind.format()]),
			[<span class="hljs-keyword">this</span>.body.format()]);
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">let</span> terms1 = [];
		<span class="hljs-keyword">let</span> overrided = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> {name, bind} <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.terms) {
			<span class="hljs-keyword">if</span> (name === id) overrided = <span class="hljs-literal">true</span>;
			terms1.push({name, <span class="hljs-attr">bind</span>: bind.subst(id, replacement)});
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Let(terms1, !overrided ? <span class="hljs-keyword">this</span>.body.subst(id, replacement) : <span class="hljs-keyword">this</span>.body);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>CHECK-LET: $\dfrac{\Gamma\vdash^* t: \sigma’\quad \Gamma, x:\sigma’\vdash u:\rho}{\Gamma\vdash(\mathbf{let}\ (x=t).u):\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} expected
	 */</span>
	_checkRho(env, expected) {
		<span class="hljs-keyword">const</span> varTys = <span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{name, bind}</span>) </span>{
			<span class="hljs-keyword">const</span> {type, tagged} = bind.inferSigma(env);
			<span class="hljs-keyword">return</span> {name, type, tagged};
		});
		<span class="hljs-keyword">const</span> env1 = env.extendN(varTys);
		<span class="hljs-keyword">const</span> ebody = <span class="hljs-keyword">this</span>.body.checkRho(env1, expected);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Let(
			varTys.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> ({<span class="hljs-attr">name</span>: x.name, <span class="hljs-attr">bind</span>: x.tagged, <span class="hljs-attr">type</span>: x.type})),
			ebody);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>INFER-LET: $\dfrac{\Gamma\vdash^* t:\sim \sigma’\quad \Gamma, x:\sigma’\vdash u:\sim\rho}{\Gamma\vdash(\mathbf{let}\ (x=t).u):\sim\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @returns{Type} 
	 */</span>
	_inferRho(env) {
		<span class="hljs-keyword">const</span> varTys = <span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{name, bind}</span>) </span>{
			<span class="hljs-keyword">const</span> {type, tagged} = bind.inferSigma(env);
			<span class="hljs-keyword">return</span> {name, type, tagged};
		});
		<span class="hljs-keyword">const</span> env1 = env.extendN(varTys);
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: t, <span class="hljs-attr">tagged</span>: ebody} = <span class="hljs-keyword">this</span>.body.inferRho(env1);
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">type</span>: t,
			<span class="hljs-attr">tagged</span>: <span class="hljs-keyword">new</span> Let(
				varTys.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> ({<span class="hljs-attr">name</span>: x.name, <span class="hljs-attr">bind</span>: x.tagged, <span class="hljs-attr">type</span>: x.type})),
				ebody)
		};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <h3 id="-let-">递归 Let 绑定</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LetRec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {Array&lt;{name: string, bind: Term, type: Type?}&gt;} terms
	 * @param {Term} body
	 */</span>
	<span class="hljs-keyword">constructor</span>(terms, body) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.terms = terms;
		<span class="hljs-keyword">this</span>.body = body;
	}
	format() {
		<span class="hljs-keyword">return</span> [<span class="hljs-string">"letrec"</span>.yellow.bold].concat(
			<span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function">(<span class="hljs-params">{name, type, bind}</span>) =&gt;</span> type
				? [<span class="hljs-string">"="</span>, [<span class="hljs-string">"::"</span>, name, type.format()], bind.format()]
				: [<span class="hljs-string">"="</span>, name, bind.format()]),
			[<span class="hljs-keyword">this</span>.body.format()]);
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">let</span> overrided = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> {name, bind, type} <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.terms) {
			<span class="hljs-keyword">if</span> (name === id) {
				overrided = <span class="hljs-literal">true</span>;
			}
		}
		<span class="hljs-keyword">let</span> terms1 = [];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> {name, bind, type} <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.terms) {
			<span class="hljs-keyword">if</span> (overrided) {
				terms1.push({name, bind, type});
			} <span class="hljs-keyword">else</span> {
				terms1.push({name, <span class="hljs-attr">bind</span>: bind.subst(id, replacement), type});
			}
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LetRec(terms1, !overrided ? <span class="hljs-keyword">this</span>.body.subst(id, replacement) : <span class="hljs-keyword">this</span>.body);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>CHECK-LETREC1: $\dfrac{\Gamma, x:\mathrm{fresh}\vdash^* t: \sigma’\quad \Gamma, x:\sigma’\vdash u:\rho}{\Gamma\vdash(\mathbf{let\ rec}\ (x=t).u):\rho}$</p>
<p>CHECK-LETREC2: $\dfrac{\Gamma, x:\sigma\vdash^* t: \sigma’\quad \Gamma, x:\sigma’\vdash u:\rho}{\Gamma\vdash(\mathbf{let\ rec}\ (x:\sigma=t).u):\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} expected
	 */</span>
	_checkRho(env, expected) {
		<span class="hljs-keyword">const</span> env1TypeBindings = <span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function">(<span class="hljs-params">{name, type}</span>) =&gt;</span> ({
			name,
			<span class="hljs-attr">type</span>: type || <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal())
		}));
		<span class="hljs-keyword">const</span> env1 = env.extendN(env1TypeBindings);
		<span class="hljs-keyword">const</span> varTys = <span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{name, bind}</span>) </span>{
			<span class="hljs-keyword">const</span> {type, tagged} = bind.inferSigma(env1);
			<span class="hljs-keyword">return</span> {name, type, tagged};
		});
		<span class="hljs-keyword">const</span> env2 = env.extendN(varTys);
		<span class="hljs-keyword">const</span> ebody = <span class="hljs-keyword">this</span>.body.checkRho(env2, expected);
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LetRec(
			varTys.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> ({<span class="hljs-attr">name</span>: x.name, <span class="hljs-attr">bind</span>: x.tagged, <span class="hljs-attr">type</span>: x.type})),
			ebody);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>INFER-LETREC1: $\dfrac{\Gamma, x:\mathrm{fresh}\vdash^* t:\sim \sigma’\quad \Gamma, x:\sigma’\vdash u:\sim\rho}{\Gamma\vdash(\mathbf{let\ rec}\ (x=t).u):\sim\rho}$</p>
<p>INFER-LETREC2: $\dfrac{\Gamma, x:\sigma\vdash^* t:\sim \sigma’\quad \Gamma, x:\sigma’\vdash u:\sim\rho}{\Gamma\vdash(\mathbf{let\ rec}\ (x:\sigma=t).u):\sim\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @returns{Type} 
	 */</span>
	_inferRho(env) {
		<span class="hljs-keyword">const</span> env1TypeBindings = <span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function">(<span class="hljs-params">{name, type}</span>) =&gt;</span> ({
			name,
			<span class="hljs-attr">type</span>: type || <span class="hljs-keyword">new</span> MetaSlot(env.newMetaSlotVal())
		}));
		<span class="hljs-keyword">const</span> env1 = env.extendN(env1TypeBindings);
		<span class="hljs-keyword">const</span> varTys = <span class="hljs-keyword">this</span>.terms.map(<span class="hljs-function">(<span class="hljs-params">{name, bind, type}</span>) =&gt;</span> {
			<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>:inferredType, <span class="hljs-attr">tagged</span>:e} = bind.inferSigma(env1);
			<span class="hljs-keyword">let</span> f = type ? type.subsCheck(env, inferredType) : <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">if</span> (f) {
				<span class="hljs-keyword">return</span> {name, <span class="hljs-attr">type</span>: inferredType,
				<span class="hljs-attr">tagged</span>: e.subst(name, <span class="hljs-keyword">new</span> Invoke(f, <span class="hljs-keyword">new</span> Var(name)))};
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> {name, <span class="hljs-attr">type</span>: inferredType, <span class="hljs-attr">tagged</span>: e};
			}
		});
		<span class="hljs-keyword">const</span> env2 = env.extendN(varTys);
		<span class="hljs-keyword">const</span> {<span class="hljs-attr">type</span>: t, <span class="hljs-attr">tagged</span>: ebody} = <span class="hljs-keyword">this</span>.body.inferRho(env2);
		<span class="hljs-keyword">return</span> {
			<span class="hljs-attr">type</span>: t,
			<span class="hljs-attr">tagged</span>: <span class="hljs-keyword">new</span> LetRec(
				varTys.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> ({<span class="hljs-attr">name</span>: x.name, <span class="hljs-attr">bind</span>: x.tagged, <span class="hljs-attr">type</span>: x.type})),
				ebody)
		};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h3 id="-">显式窄化</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annotate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {Type} type
	 * @param {Term} body
	 */</span>
	<span class="hljs-keyword">constructor</span>(body, type) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.body = body;
		<span class="hljs-keyword">this</span>.type = type;
	}
	format() {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.body.format();</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>return [“::”, this.body.format(), this.type.zonk().format()];</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	}
	subst(name, replacement) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(<span class="hljs-keyword">this</span>.body.subst(name, replacement), <span class="hljs-keyword">this</span>.type);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>CHECK-ANN: $\dfrac{\Gamma\vdash^* t:\sigma \quad \sigma\le\rho}{\Gamma\vdash(t:\sigma):\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @param{Type} expected
	 */</span>
	_checkRho(env, expected) {
		<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">this</span>.body.checkSigma(env, <span class="hljs-keyword">this</span>.type);
		<span class="hljs-keyword">const</span> f = <span class="hljs-keyword">this</span>.type.instSigmaCheck(env, expected);
		<span class="hljs-keyword">return</span> f(e);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>INFER-ANN: $\dfrac{\Gamma\vdash^* t:\sigma \quad \sigma\le\sim\rho}{\Gamma\vdash(t:\sigma):\sim\rho}$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-comment">/**
	 * @param{Environment} env
	 * @returns{Type}
	 */</span>
	_inferRho(env) {
		<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">this</span>.body.checkSigma(env, <span class="hljs-keyword">this</span>.type);
		<span class="hljs-keyword">const</span> {type, <span class="hljs-attr">coercion</span>:f} = <span class="hljs-keyword">this</span>.type.instSigmaInfer(env);
		<span class="hljs-keyword">return</span> {type, <span class="hljs-attr">tagged</span>: f(e)};
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>以下的项目为 System F 的高阶构造，它们主要用于构造约制子。</p>
<h3 id="system-f-lambda-overline-alpha-e-">System-F 类型抽象，$\Lambda\overline\alpha.e$</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {Array&lt;Slot&gt;} quantifiers
	 * @param {Term} body
	 */</span>
	<span class="hljs-keyword">constructor</span>(quantifiers, body) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.quantifiers = quantifiers;
		<span class="hljs-keyword">this</span>.body = body;
	}
	format() {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.quantifiers.length) {
			<span class="hljs-keyword">return</span> [<span class="hljs-string">"generic"</span>.green.bold, <span class="hljs-keyword">this</span>.quantifiers.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-keyword">new</span> Slot(x).format()), <span class="hljs-keyword">this</span>.body.format()];
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.body.format();
		}
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(id, replacement) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Generic(<span class="hljs-keyword">this</span>.quantifiers, <span class="hljs-keyword">this</span>.body.subst(id, replacement));
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <h3 id="system-f-mathrm-inst-alpha-rightarrow-rho-lambda-x-x-alpha-rho-">System-F 显式类型实例化。$\mathrm{Inst}(\alpha\rightarrow\rho)=\lambda x.x^{{\alpha=\rho}}$</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inst</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Term</span> </span>{
	<span class="hljs-comment">/**
	 * @param {Term} body
	 * @param {Map&lt;string, Type&gt;} args
	 */</span>
	<span class="hljs-keyword">constructor</span>(body, args) {
		<span class="hljs-keyword">super</span>();
		<span class="hljs-keyword">this</span>.body = body;
		<span class="hljs-keyword">this</span>.args = args;
	}
	format() {
		<span class="hljs-keyword">let</span> buf = [];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.args) {
			buf.push([<span class="hljs-string">"="</span>, <span class="hljs-keyword">new</span> Slot(k).format(), v.zonk().format()]);
		}
		<span class="hljs-keyword">return</span> [<span class="hljs-string">"inst"</span>.green.bold, <span class="hljs-keyword">this</span>.body.format()].concat(buf);
	}
	<span class="hljs-comment">/**
	 * @param{string} id
	 * @param{Term} replacement
	 * @returns{Term}
	 */</span>
	subst(name, replacement) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Inst(<span class="hljs-keyword">this</span>.body.subst(name, replacement), <span class="hljs-keyword">this</span>.args);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <h2 id="-">测试部分</h2>
<h4 id="translatetype-any-type">translateType :: [any] → Type</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @returns{Type}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">translateType</span>(<span class="hljs-params">a</span>) </span>{
	<span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
		<span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"forall"</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForAll(
				a[<span class="hljs-number">1</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> translateType(x).name),
				translateType(a[<span class="hljs-number">2</span>])
			);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"exists"</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Existential 类型可以用普通的多态类型模拟</p>
<p>$\exists \overline x. \rho = \forall Q. (\forall \overline x. \rho \rightarrow Q)\rightarrow Q$</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForAll([<span class="hljs-string">"Q"</span>],
				FunctionType(<span class="hljs-keyword">new</span> ForAll(
					a[<span class="hljs-number">1</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> translateType(x).name),
					FunctionType(translateType(a[<span class="hljs-number">2</span>]), <span class="hljs-keyword">new</span> Slot(<span class="hljs-string">"Q"</span>))
				), <span class="hljs-keyword">new</span> Slot(<span class="hljs-string">"Q"</span>)));
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.length === <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>我们目前只知道 $\rightarrow$ 是反变的，因此只处理这一种情况。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Composite(
				translateType(a[<span class="hljs-number">0</span>]),
				translateType(a[<span class="hljs-number">1</span>]),
				a[<span class="hljs-number">0</span>] === <span class="hljs-string">"-&gt;"</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">const</span> fnpart = translateType(a.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>));
			<span class="hljs-keyword">const</span> argpart = translateType(a[a.length - <span class="hljs-number">1</span>]);
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Composite(fnpart, argpart, <span class="hljs-literal">false</span>);
		}
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"'"</span>) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Slot(a.slice(<span class="hljs-number">1</span>));
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Primitive(a);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <h4 id="translate-any-term">translate :: [any] → Term</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @returns{Term}
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">translate</span>(<span class="hljs-params">a</span>) </span>{
	<span class="hljs-keyword">if</span> (!a) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Literal(a);
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
		<span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"let"</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Let(
				a.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>).map(<span class="hljs-function"><span class="hljs-params">form</span> =&gt;</span> ({<span class="hljs-attr">name</span>: form[<span class="hljs-number">0</span>], <span class="hljs-attr">bind</span>: translate(form[<span class="hljs-number">1</span>])})),
				translate(a[a.length - <span class="hljs-number">1</span>]));
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"letrec"</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LetRec(
				a.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>).map(<span class="hljs-function"><span class="hljs-params">form</span> =&gt;</span> ({
					<span class="hljs-attr">name</span>: form[<span class="hljs-number">0</span>],
					<span class="hljs-attr">bind</span>: translate(form[<span class="hljs-number">1</span>]),
					<span class="hljs-attr">type</span>: form[<span class="hljs-number">2</span>] ? translateType(form[<span class="hljs-number">2</span>]) : <span class="hljs-literal">null</span>
				})),
				translate(a[a.length - <span class="hljs-number">1</span>]));
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"lambda"</span> &amp;&amp; a.length &gt;= <span class="hljs-number">3</span>) {
			<span class="hljs-keyword">const</span> fn0 = translate(a[a.length - <span class="hljs-number">1</span>]);
			<span class="hljs-keyword">return</span> a.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>).reduceRight(<span class="hljs-function">(<span class="hljs-params">fn, term</span>) =&gt;</span> (<span class="hljs-keyword">typeof</span> term === <span class="hljs-string">"string"</span>)
				? <span class="hljs-keyword">new</span> Lambda(term, fn)
				: <span class="hljs-keyword">new</span> AnnotatedLambda(term[<span class="hljs-number">0</span>], translateType(term[<span class="hljs-number">1</span>]), fn), fn0);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"begin"</span>) {
			<span class="hljs-keyword">return</span> translate(a.slice(<span class="hljs-number">1</span>).reduceRight(<span class="hljs-function">(<span class="hljs-params">y, x</span>) =&gt;</span> [<span class="hljs-string">"seq"</span>, x, y]));
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] === <span class="hljs-string">"::"</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Annotate(translate(a[<span class="hljs-number">1</span>]), translateType(a[<span class="hljs-number">2</span>]));
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.length === <span class="hljs-number">2</span>) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Invoke(translate(a[<span class="hljs-number">0</span>]), translate(a[<span class="hljs-number">1</span>]));
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Invoke(translate(a.slice(<span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>)), translate(a[a.length - <span class="hljs-number">1</span>]));
		}
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">"string"</span>) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Var(a);
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Literal(a);
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>测试：「全局变量」表</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> env = <span class="hljs-keyword">new</span> Environment({ <span class="hljs-attr">val</span>: <span class="hljs-number">0</span> }, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
	[<span class="hljs-string">"&amp;"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'a"</span>, <span class="hljs-string">"'b"</span>],
		[<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'a"</span>,
			[<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'b"</span>,
				[<span class="hljs-string">"*"</span>, <span class="hljs-string">"'a"</span>, <span class="hljs-string">"'b"</span>]]]])],
	[<span class="hljs-string">"id"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'a"</span>, <span class="hljs-string">"'a"</span>]])],
	[<span class="hljs-string">"+"</span>, translateType([<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"int"</span>, [<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"int"</span>, <span class="hljs-string">"int"</span>]])],
	[<span class="hljs-string">"-"</span>, translateType([<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"int"</span>, [<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"int"</span>, <span class="hljs-string">"int"</span>]])],
	[<span class="hljs-string">"empty?"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"-&gt;"</span>, [<span class="hljs-string">"list"</span>, <span class="hljs-string">"'a"</span>], <span class="hljs-string">"bool"</span>]])],
	[<span class="hljs-string">"zero?"</span>, translateType([<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"int"</span>, <span class="hljs-string">"bool"</span>])],
	[<span class="hljs-string">"cdr"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"-&gt;"</span>, [<span class="hljs-string">"list"</span>, <span class="hljs-string">"'a"</span>], [<span class="hljs-string">"list"</span>, <span class="hljs-string">"'a"</span>]]])],
	[<span class="hljs-string">"if"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"-&gt;"</span>,
		<span class="hljs-string">"bool"</span>,
		[<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'a"</span>, [<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'a"</span>, <span class="hljs-string">"'a"</span>]]]])],
	[<span class="hljs-string">"somelist"</span>, translateType([<span class="hljs-string">"list"</span>, <span class="hljs-string">"int"</span>])],
	[<span class="hljs-string">"box"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'t"</span>], [<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'t"</span>, [<span class="hljs-string">"exists"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"box"</span>, <span class="hljs-string">"'a"</span>]]]])],
	[<span class="hljs-string">"box_list"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'t"</span>], [<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'t"</span>, [<span class="hljs-string">"exists"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"box"</span>, [<span class="hljs-string">"list"</span>, <span class="hljs-string">"'a"</span>]]]]])],
	[<span class="hljs-string">"unbox"</span>, translateType([<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'t"</span>], [<span class="hljs-string">"-&gt;"</span>, [<span class="hljs-string">"exists"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"box"</span>, <span class="hljs-string">"'a"</span>]], <span class="hljs-string">"'t"</span>]])]
]));</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>测试：程序</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> a = translate(
	[<span class="hljs-string">"letrec"</span>,
		[<span class="hljs-string">"even?"</span>, [<span class="hljs-string">"lambda"</span>, [<span class="hljs-string">"x"</span>, <span class="hljs-string">"int"</span>],
			[<span class="hljs-string">"if"</span>, [<span class="hljs-string">"zero?"</span>, <span class="hljs-string">"x"</span>],
				<span class="hljs-literal">true</span>,
				[<span class="hljs-string">"odd?"</span>, [<span class="hljs-string">"-"</span>, <span class="hljs-string">"x"</span>, <span class="hljs-number">1</span>]]]]],
		[<span class="hljs-string">"odd?"</span>, [<span class="hljs-string">"lambda"</span>, [<span class="hljs-string">"x"</span>, <span class="hljs-string">"int"</span>],
			[<span class="hljs-string">"if"</span>, [<span class="hljs-string">"zero?"</span>, <span class="hljs-string">"x"</span>],
				<span class="hljs-literal">false</span>,
				[<span class="hljs-string">"even?"</span>, [<span class="hljs-string">"-"</span>, <span class="hljs-string">"x"</span>, <span class="hljs-number">1</span>]]]]],
		[<span class="hljs-string">"id"</span>, [<span class="hljs-string">"lambda"</span>, <span class="hljs-string">"x"</span>, <span class="hljs-string">"x"</span>]],
		[<span class="hljs-string">"id_dyn"</span>,
			[<span class="hljs-string">"lambda"</span>,
				[<span class="hljs-string">"x"</span>, [<span class="hljs-string">"exists"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"box"</span>, <span class="hljs-string">"'a"</span>]]],
				[<span class="hljs-string">"::"</span>, [<span class="hljs-string">"unbox"</span>, <span class="hljs-string">"x"</span>], [<span class="hljs-string">"list"</span>, <span class="hljs-string">"int"</span>]]],
			[<span class="hljs-string">"-&gt;"</span>, [<span class="hljs-string">"exists"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"box"</span>, <span class="hljs-string">"'a"</span>]], [<span class="hljs-string">"list"</span>, <span class="hljs-string">"int"</span>]]],
		[<span class="hljs-string">"let"</span>,
			[<span class="hljs-string">"strange"</span>,
				[<span class="hljs-string">"lambda"</span>,
					[<span class="hljs-string">"f"</span>, [<span class="hljs-string">"forall"</span>, [<span class="hljs-string">"'a"</span>], [<span class="hljs-string">"-&gt;"</span>, <span class="hljs-string">"'a"</span>, <span class="hljs-string">"'a"</span>]]],
					[<span class="hljs-string">"&amp;"</span>, [<span class="hljs-string">"f"</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">"f"</span>, [<span class="hljs-string">"even?"</span>, <span class="hljs-number">5</span>]]]]],
			[<span class="hljs-string">"&amp;"</span>, [<span class="hljs-string">"strange"</span>, <span class="hljs-string">"id"</span>], [<span class="hljs-string">"id_dyn"</span>, [<span class="hljs-string">"box_list"</span>, <span class="hljs-number">1</span>]]]]]
);</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Pretty-print formatting</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> COLORS = [<span class="hljs-string">"grey"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"cyan"</span>];
<span class="hljs-keyword">const</span> COLUMNS = <span class="hljs-number">100</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatToStr</span>(<span class="hljs-params">form, depth, infix, compact</span>) </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> form === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> form;
	<span class="hljs-keyword">if</span> (!infix &amp;&amp; form.length === <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-keyword">typeof</span> form[<span class="hljs-number">0</span>] === <span class="hljs-string">"string"</span> &amp;&amp; !<span class="hljs-regexp">/[\wΛλ]/</span>.test(stripAnsi(form[<span class="hljs-number">0</span>]))) {
		<span class="hljs-keyword">return</span> formatToStr([form[<span class="hljs-number">1</span>], form[<span class="hljs-number">0</span>].magenta, form[<span class="hljs-number">2</span>]], depth, <span class="hljs-literal">true</span>, compact);
	}
	<span class="hljs-keyword">const</span> shorts = [];
	<span class="hljs-keyword">let</span> shortlen = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> subform <span class="hljs-keyword">of</span> form) {
		shorts.push(formatToStr(subform, depth + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, compact));
		shortlen += stripAnsi(shorts[shorts.length - <span class="hljs-number">1</span>]).length;
	}
	<span class="hljs-keyword">if</span> (compact || shortlen &lt; COLUMNS) {
		<span class="hljs-keyword">return</span> (infix ? <span class="hljs-string">"("</span> : <span class="hljs-string">"["</span>)[COLORS[depth % COLORS.length]]
		+ shorts.join(<span class="hljs-string">" "</span>)
		+ (infix ? <span class="hljs-string">")"</span> : <span class="hljs-string">"]"</span>)[COLORS[depth % COLORS.length]];
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">let</span> buf = (infix ? <span class="hljs-string">"("</span> : <span class="hljs-string">"["</span>)[COLORS[depth % COLORS.length]];
		<span class="hljs-keyword">let</span> lensofar = <span class="hljs-number">0</span>, indent = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; shorts.length; j++) {
			lensofar += stripAnsi(shorts[j]).length;
			indent = indent || lensofar &gt;= COLUMNS;
			buf += ((indent &amp;&amp; j) ? <span class="hljs-string">"\n"</span> + <span class="hljs-string">"  "</span>.repeat(depth) : <span class="hljs-string">" "</span>) + shorts[j];
		}
		<span class="hljs-keyword">return</span> buf + (infix ? <span class="hljs-string">")"</span> : <span class="hljs-string">"]"</span>)[COLORS[depth % COLORS.length]];
	}
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Program:"</span>, formatToStr(a.format(), <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\nEnvironment:"</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> env.variables.entries()) {
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"    "</span>, k, <span class="hljs-string">"::"</span>, formatToStr(v.format(), <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));
}
<span class="hljs-keyword">const</span> {type, tagged} = a.inferSigma(env);</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>应当返回：<code>(int * boolean) * list int</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\nType:"</span>, formatToStr(type.format(), <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>应当返回：程序 a 的已标记版本</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\nSystem F Notations: "</span>, formatToStr(tagged.format(), <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>